# KVTree 是 QuickKV 的词库管理器
KVTree （KVT）支持你在任意 Markdown 笔记软件内用无序列表树（大纲）方式管理[QuickKV（QKV）](https://github.com/msjsc001/QuickKV)词库，笔记软件内建立的词库软件会自动转换生成为 QuickKV 词库输出到指定目录下。这样**极大的方便了我们查看和管理已有的词条，词库里有什么词不会再产生疑惑**。大规模的管理建议使用Obsidian或Logseq（md版），KVT和QKV都能轻松支持百万量级的".md"文件。


<img src="https://github.com/user-attachments/assets/a65d8d84-97b6-413e-89e9-0883df4dbcb9" />
（看上图就能学会使用）

<p align="center">
  <a href="https://github.com/msjsc001/KV-Tree/releases/latest"><img src="https://img.shields.io/github/v/release/msjsc001/KV-Tree"></a>
  <a href="https://github.com/msjsc001/KV-Tree/commits/master"><img src="https://img.shields.io/github/last-commit/msjsc001/KV-Tree"></a>
  <a href="https://github.com/msjsc001/KV-Tree/releases"><img src="https://img.shields.io/github/downloads/msjsc001/KV-Tree/total?label=Downloads&color=brightgreen"></a>
</p>

---

## 核心功能

- **智能标签识别**: 通过在您的笔记条目后添加特定标签（如 `#KV树-读书词库`），精确提取所需内容。
- **多种提取模式**: 支持“单行”、“父与子”、“不包含父”三种灵活的提取模式，完美适应您不同的笔记组织习惯。
- **层级关系保留**: 能够准确理解和保留笔记中的缩进层级关系，确保生成的词库结构与您的笔记一致。
- **文件监控与自动生成**: 启用“自动生成”后，KVTree 会在后台监控您的源文件，一旦发生更改，便会自动更新对应的词库，让您专注于内容创作。
- **灵活的规则定义**: 支持自定义排除和替换规则，让您在提取过程中可以轻松过滤掉元数据、注释等无关内容。
- **[新] Logseq页眉属性扫描**: 新增专门针对Logseq用户的扫描功能，可以从`.md`文件的页眉中提取属性的键（如 `tags::`）和值（如 `[[TODO]]`）来构建词库。
- **[新] 系统集成**: 支持设置“开机自启”和“最小化到系统托盘”，提升日常使用便利性。
- **简洁直-观的UI**: 使用轻量级的 `Tkinter` 构建，界面简洁，操作直观，无需学习成本即可上手。

---

## 开发路线图

- [✔️]加入对文件夹级（库）别的识别输出的支持
- [ ]可能考虑和QKV的融合

---

## 新手入门教程


### 第1步：准备您的笔记源文件

在您的 Markdown 笔记软件中（如 Typora, VSCode 等），按照大纲笔记的方式组织您的词条。

**关键点**：在需要提取的词条**行尾**，加上 `#KV树-词库名` 格式的标签。

`#KV树-词库名` 其中`#KV树-词库名`最终会成为生成的词库名。
带后缀的`#KV树-词库名-父与子`、`#KV树-词库名-不包含父`则是功能选择
  - 后缀是`父与子`的无序列表的父级和子级都会被作为词条。
  - 后缀是`不包含父`的无序列表的子级会被作为词条。
  - 如果没后后缀则只用这行内容建立一个车词条。
**！需要注意的是，如果标签取消，词库中的词、和文件也会被取消，KVTree 生成的文件和词库和源文件是镜像关系**

**示例 `我的笔记.md`:**
```markdown
- 个人知识管理
    - 卡片笔记法 #KV树-方法论词库
        - 卢曼
    - 渐进式总结 #KV树-方法论词库
- GTD (Getting Things Done) #KV树-效率工具-父与子
    - 收件箱
    - 下一步行动
    - 项目
- 阅读 #KV树-我的词库-不包含父
    - 《如何阅读一本书》
    - 《卡片笔记写作法》
```

### 第2步：运行 KVTree

直接运行 `kv_tree_app.py` 即可启动程序。

### 第3步：添加源文件并生成词库

1.  **添加源文件**: 点击界面左上角的“添加”按钮，选择您刚才编辑的 `我的笔记.md`。
2.  **选择输出位置**: 点击“输出”区域的“选择”按钮，指定您希望存放 QuickKV 词库的文件夹。
3.  **生成词库**: 点击右下角的“!! 生成 !!”按钮。

### 第4步：查看结果

程序将根据您的标签，在您指定的输出位置生成对应的词库文件：

**`#KV树-方法论词库.md`**:
```markdown
- 卡片笔记法
- 渐进式总结
```

**`#KV树-效率工具.md`**:
```markdown
- GTD (Getting Things Done)
    - 收件箱
    - 下一步行动
    - 项目
```

**`#KV树-我的词库.md`**:
```markdown
- 《如何阅读一本书》
- 《卡片笔记写作法》
```

现在，您只需将这些生成的 `.md` 文件放入 QuickKV 的词库目录，即可开始使用。

---

### 针对 Logseq 用户的新功能

如果您是 Logseq 用户，现在可以利用新增的属性扫描功能，直接从笔记的页眉（Page Properties）中提取词条。

1.  **启用功能**:
    -   在主界面点击“**高级选项**”按钮。
    -   在弹出的窗口中，根据您的需要勾选：
        -   `页头属性键录入为词条`：会提取所有 `key::` 格式的键。例如，从 `tags:: [[任务]], [[项目]]` 中提取 `- tags::`。
        -   `页头属性值录入为词条-带双方括号[[]]的`：会提取所有 `[[value]]` 格式的值。例如，从 `tags:: [[任务]], [[项目]]` 中提取 `- [[任务]]` 和 `- [[项目]]`。

2.  **生成结果**:
    -   启用后，点击“!! 生成 !!”，程序会在您的输出目录中创建一个名为 `Logseq属性键值.md` 的词库文件。
    -   此功能与原有的 `#KV树` 标签功能**同时生效**，互不干扰。

---

## 技术实现深度解析

### UI 方法

KVTree 采用 Python 内置的 **`Tkinter`** 库构建图形用户界面。

- **选择原因**:
    - **轻量级与跨平台**: 作为 Python 的标准库，`Tkinter` 无需任何额外依赖，打包后的程序体积小，且能在 Windows, macOS, Linux 上原生运行。
    - **快速开发**: 对于 KVTree 这种功能明确、交互直接的工具型应用，`Tkinter` 能够以最少的代码快速构建出功能完备的界面。
    - **易于维护和拓展**: 代码结构简单，所有UI组件都在 `KvTreeApp` 类的 `__init__` 方法中进行初始化，逻辑清晰，便于未来增加新的UI元素或修改布局。

### 匹配方法：为何它能很好地匹配内容？

KVTree 的核心优势在于其先进的解析引擎 `AstParser`，它摒弃了传统基于正则表达式的行匹配方式，采用**抽象语法树（Abstract Syntax Tree, AST）**进行解析。

- **工作原理**:
    1.  **标准化输入**: 首先，程序会将所有 `Tab` 字符统一转换成4个空格，为精确计算缩进奠定基础。
    2.  **构建AST**: 程序会逐行读取您的笔记，并根据每一行的**缩进量**，在内存中构建一个与您笔记层级结构完全一致的“树”。每一个笔记条目都是树上的一个“节点（Node）”，节点之间有明确的父子关系。
    3.  **两阶段处理**:
        - **第一阶段（处理块）**: 程序首先遍历整棵树，寻找所有定义了“块级作用域”的标签（即 `父与子` 和 `不包含父`）。一旦找到，它就会根据模式，完整地处理这个节点和它的所有子孙，并给它们全部打上“已处理”的标记。
        - **第二阶段（处理单行）**: 接着，程序再次遍历整棵树，处理所有在第一阶段**未被标记**的、带标签的节点。这些节点自然就是“单行”模式。

- **优势**:
    - **精确性**: AST 完美地映射了笔记的层级关系，因此可以100%准确地提取“父与子”或“不包含父”的内容，不会像正则表达式那样因为复杂的嵌套而出错。
    - **健壮性与关注点分离**: `AstParser` 保证了大纲解析的精确性，而 `LogseqParser` 则为平面化的键值对提取提供了高效的解决方案。两者各司其职，代码逻辑清晰。
    - **可维护性**: 所有解析逻辑都封装在 `app_logic` 目录下的对应模块中，与UI代码完全分离。这使得为特定需求（如未来支持Obsidian元数据）增加新的解析器变得非常简单，只需在 `proc_all` 中加入新的调用分支即可。

### 输出方法

程序的输出逻辑位于 `KvTreeApp` 类的 `proc_all` 方法中。

1.  调用 `AstParser` 的 `parse` 方法，获取一个以词库文件名（如 `#KV树-读书词库.md`）为键，以要写入的内容列表为值的字典。
2.  遍历这个字典，对每一个词库文件：
    - **解锁文件**: 如果文件已存在且为只读，则先移除其只读属性。
    - **写入内容**: 以“覆盖写”（`"w"`）的方式打开文件，并将内容列表中的每一行用换行符连接后写入。
    - **锁定文件**: 写入完成后，立即将文件属性设置为**只读**，以防止意外修改，确保其作为QuickKV词库的稳定性。

---

## 开发者指南

### 环境搭建

本项目主要使用 Python 标准库开发，但引入了少量第三方库以支持更丰富的功能。

- **`pystray`**: 用于实现系统托盘图标功能。
- **`Pillow`**: 用于图像处理，例如动态创建图标。

您只需要一个标准的 Python 3.x 环境，并安装所需依赖。

1.  克隆本项目到本地。
2.  建议在项目根目录创建一个虚拟环境：
    ```bash
    python -m venv venv
    source venv/bin/activate  # on Windows, use `venv\Scripts\activate`
    ```
3.  **安装依赖**:
   ```bash
   pip install -r requirements.txt
   # 或者手动安装: pip install pystray Pillow
   ```
4.  直接运行主程序：
    ```bash
    python kv_tree_app.py
    ```

### 文件结构 (v0.3 重构后)

```
.
├── app_logic/              # 核心逻辑模块文件夹
│   ├── __init__.py
│   ├── ast_parser.py         # KV树标签的AST解析器
│   ├── config_manager.py     # 配置加载/保存模块
│   ├── file_monitor.py       # 文件监控线程模块
│   └── logseq_parser.py      # Logseq属性扫描解析器 (新)
├── kv_tree_app.py          # 主程序：UI界面与逻辑调度
├── kv_tree_config.json     # 配置文件：保存源文件列表、输出路径和规则
└── README.md               # 本文档
```

### 如何继续开发？

1.  **修改解析逻辑**:
    -   要修改 `#KV树` 标签的功能，请编辑 `app_logic/ast_parser.py`。
    -   要修改 Logseq 属性扫描的功能，请编辑 `app_logic/logseq_parser.py`。
2.  **修改UI**: 所有界面元素和布局都在 `kv_tree_app.py` 中定义。
3.  **修改配置管理**: 如果想添加新的需要保存的设置项，请更新 `app_logic/config_manager.py`。

### 未来可拓展方向

- **词条冲突检测**: 在 `proc_all` 方法中，对最终生成的词库内容进行分析，如果发现完全相同的词条，可以在状态栏给出警告，或提供更高级的合并策略。
- **更丰富的规则**: 可以在 `ast_parser.py` 中增加对更多类型规则的支持，例如按日期范围提取、按特定元数据过滤等。
- **打包为可执行文件**: 使用 `PyInstaller` 或 `cx_Freeze` 等工具，可以将本项目轻松打包为单个 `.exe` (Windows) 或 `.app` (macOS) 文件，方便非技术用户使用。

---

## 编译

如何将此程序编译为独立的 `.exe` 文件：

1.  **安装 PyInstaller**:
    ```bash
    pip install pyinstaller
    ```

2.  **编译**:
    在项目根目录下运行以下命令来创建最终的发行版：
    ```bash
    pyinstaller --name "KVTree" --onefile --noconsole --icon="icon.ico" --add-data "icon.ico;." --add-data "app_logic;app_logic" kv_tree_app.py
    ```
    参数详解:
    *   `--name "KVTree"`: 指定生成的 exe 文件名为 `KVTree.exe`。
    *   `--onefile`: 将所有依赖和资源打包到**单个可执行文件**中。
    *   `--noconsole` (或 `--windowed`): **无黑窗运行**，这是GUI应用的推荐设置。
    *   `--icon="icon.ico"`: 将 `icon.ico` 设置为 `exe` 文件的**程序图标**。
    *   `--add-data "icon.ico;."`: 将图标文件**包含到** `exe` 内部，以便程序在运行时能找到它并用于系统托盘。
    *   `--add-data "app_logic;app_logic"`: **非常重要**，此命令会将整个 `app_logic` 文件夹及其中的所有 `.py` 脚本都包含到 `exe` 中，确保核心逻辑模块能够被正确加载。

3.  **结果**:
    编译完成后，可在 `dist` 文件夹中找到 `kv_tree_app.exe`。

## 更新日志
- ✔️V0.5 [[让KVT 能随系统启动，最小化时在托盘]]
- ✔️V0.4
	- [[KVT选择输出]]（在结果列表可以勾选，被勾选的才会被输出，不被勾选的会被清理且不会输出）
- ✔️V0.3
	- [[让KVT能扫描Logseq md文件的特定属性键值]] #L-M管理 、未来健壮性考虑重构代码原子化脚本
- ✔️V0.2
	- ✔️[[让KVT能扫描指定文件夹]]、未来健壮性考虑重构代码原子化脚本
- ✔️V0.1
	- ✔️自动去除源文件内标签已经没有的 旧md文件
		- 也就是，软件需要记忆生成过的词库，如果识别的源文件内的标签已经没有该文件名则删除该没有的文件。
		- 比如根据 `#KV树-读书词库.md` 建立过 `#KV树-读书词库.md` 文件，但现在这个词条已经没了，或者已经改变原来的 `#KV树-读书词库.md` 文件就应该去除。
		- 另外输出的文件不要是`#KV树-读书词库.md`有两个后缀。
	- ✔️添加版本号
